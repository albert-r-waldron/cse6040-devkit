# Assignment walkthrough

## Full devkit installation

## Environment

For local development, you should use a similar environment to your deployment environment. For Vocareum, the included `environment.yaml` can be used to set up a conda environment.

```sh
conda env create -f environment.yaml
```

## Installation

In your newly created environment, install from GitHub with pip. (Replace "v1.0.0" with the release version you wish to install.)

```sh
conda activate voc

pip install git+https://github.gatech.edu/cse6040-staff/cse6040-devkit-package.git@v1.0.0
```

## Blueprints and builders

The assignment framework has a few levels of hierarchy.

- **Exercise components** are individual pieces to an exercise. For example, the solution to an exercise named "fizzbuzz" is a component.

- **Assignment blueprints** are used to organize components based on the exercise name and the type of component.

- **Assignment builders** are used to organize one or more blueprints into a form that can be translated into a Jupyter notebook.

In practice we use decorators to register Python functions as exercise components under an `AssignmentBlueprint` object, and then register all blueprints under an `AssignmentBuilder` object. Finally we invoke the builder's `build` method to create the assignment notebook.


## Solution components

These define the "correct" solution. 

Using the `register_solution` decorator will register the decorated function as the solution for an exercise. 

Optionally, solutions can be designated as "free", and strings can be processed as SQL queries.

## Helper components

These define a "helper" function to be defined inline for use in an exercise.

Using the `register_helper` decorator will register the decorated function as the helper for an exercise. (Currently limited to one per exercise)

## Demo components

These define the "demo" for an exercise. 

Using the `register_demo` decorator will register the decorated function as the demo for an exercise.

Demos should define (or load) simplified inputs, call the solution with those inputs, and display the result. 

Registration will capture printed output and display it as text in the markdown, giving the students a visual to compare with.

Optionally, returned results can be captured to be serialized and/or displayed.

## Sampler components

These define the test cases used for an exercise. The sampler function generates randomized inputs for the solution function.

Using the `register_sampler` decorator will register the decorated function as the sampler for an exercise.

Optional arguments allow tests to use plugins, which can allow testing a wider variety of solution functions.

## Plugins

A plugin is a function which takes the solution and produces a function that uses the solution to derive additional results. 

One useful example is a plugin which catches runtime errors that a solution is required to raise under certain input conditions. (Solutions raising runtime errors is not allowed in the testing framework.)

There are built-in plugins (`plugins` module) or you can register your own to a blueprint with the `register_plugin` decorator.

### Usage in samplers

To set up a sampler to use a plugin, you can use the following optional arguments.

- `plugin`: set to the name of the plugin being used
- `extra_param_names`: list of additional arguments needed by the plugin result but not the original function. The sampler must generate these.
- `**plugin_kwargs`: any additional named arguments.

Both the test case generator and the test cell in the notebook will call

```py
# assuming these parameters
# 
# sol_func = some_solution_function
# plugin = 'some_plugin'
# extra_param_names = ['foo', 'bar']
# sort_key = lambda x: (x[1], -x[0])

# ultimate function call

some_plugin(some_solution_function, sort_key=lambda x: (x[1], -x[0]))(**input_vars)

# foo and bar are expected to be part of the input_vars generated by the sampler
```

## Utils

These are functions which do useful things, like file operations, where we don't see value in exposing the code to students.

There are several built in (`utils` module), or you can register your own with the `register_util` decorator.

## Advanced demo

For DataFrames, and other complex data, printing isn't the best way to show the data. Demo registration allows specifying a function to render the returned output as markdown and code to replace the return statement in student code.

## Database connections

Database connections can be made available as test inputs by returning slightly different sampler output format. The name of the connection should be mapped to a dictionary mapping table names to DataFrames. In addition to the usual dict, a second return value containing the name of the connection should be returned.