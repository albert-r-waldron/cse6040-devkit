# The `assignment` module API

The assignment module consists of two classes. The `AssignmentBlueprint` is a container for organizing the Python components which make up the core of an assignment. The `AssignmentBuilder` extends `AssignmentBlueprint` with functionality to combine multiple blueprints and build the Jupyter notebook and accompanying data files for the assignment.  

## AssignmentBlueprint

### Constructor

#### `AssignmentBlueprint(keys_path: str, include_hidden=True)`

> Initializes project if not done already:
>
> - creates `resource/asnlib/publicdata/encrypted` if it doesn't exist
> - creates encryption keys and random seeds and stores in `keys_path` if that file does not exist. (`keys_path` defaults to `keys.dill`)
>
> Reads file at `keys_path` and creates an `AssignmentBlueprint`.
>
> The `include_hidden` parameter toggles whether hidden tests are included by default.

### Methods

#### `@register_solution(ex_name: str, free=False, wrap_solution=True)`

> Decorates a function to register it as the _**solution**_ to exercise `ex_name`.  
>
> The prompt for `ex_name` will include the function _docstring_.
>
> The startercode will include the function definition with the docstring stripped out. Unless `wrap_solution` is set to `False`, the function **body** will be wrapped with `### BEGIN SOLUTION` and `### END SOLUTION` lines.
>
> A test cell for `ex_name` will be included in the starter code. It will be blank if `free` is `True` or if no **sampler** is registered for `ex_name`.

The solution function should meet these criteria. If meeting the criteria isn't possible, the preferred option is to use a _**plugin**_ to wrap the solution so that it does meet them:

- executes without raising errors
- does not modify its inputs
- is deterministic (same inputs -> same outputs)
- inputs and outputs supported types  
  - These are tested, but others may work: `int, float, bool, str, list, dict, tuple, set, function, numpy.ndarray, pandas.Series, pandas.DataFrame, sqlite3 connection (input only)`

#### `register_sql_query`_`(ex_name: str, query: str, doc: str, include_note=False)`_

> Registers the `query` as the _**solution**_ to exercise `ex_name`. The `doc` describes relavent details about the source tables and query logic.  
>
> The starter code for the `ex_name` solution will include
>
> - a stub for the student to define the string, `{ex_name}_query`
> - (auto-obscured) the `{ex_name}_query` set to `{query}`
>
> The prompt for `ex_name` will include `doc`
>
> The `sol_func` argument for the `ex_name` _**sampler**_ should be `{ex_name}_query`

#### `@register_demo`_`(ex_name: str, return_values_transformer: function|None=None, return_replacement: str|None=None)`_

> **Decorates** a function to register it as the _**demo**_ for exercise `ex_name`.
>
> The starter code for the `ex_name` solution will include the **function body** (not the signature), dedented one level. This will be placed below the solution stub, so that the solution function can be called.
>
> If the function has a `return` statement
>
> - the returned value is captured and registered as a _**preload object**_ for `ex_name`
> - if `return_replacement` is provided, the `return` statement in the function body is replaced with the "code-as-string" `return_replacement` value. Otherwise, the `return` statement is removed.
> - if `return_values_transformer` is provided, it is expected to take the `return` value as a parameter and output a string which will be part of the `ex_name` demo description.
>
> If the function prints to stdout, the output is captured and will be part of the `ex_name` demo description.
>
> If the function has a _docstring_, it will be included in the `ex_name` demo description.

#### `@register_sampler(ex_name: str, sol_func: function, n_cases: int, output_names: tuple|str, plugin: str='', extra_param_names: list[str]|None=None, include_hidden: bool|None=None, **plugin_kwargs)`

A sampler function should take one `numpy.random.Generator` input, `rng`, and return a dictionary mapping parameter names to suitable test values generated by the `rng`.

- If one of the parameters is a _database connection_, the sampler should return the dictionary as well as a string indicating which parameter is the connection. The mapped value for the connection should be a dictionary mapping table names to DataFrames

> **Decorates** a function to register it as the _**sampler**_ for exercise `ex_name`. It will use `sol_func` to execute the samples to create `n_cases` test-cases for `ex_name`. The output(s) in the test-cases will be named `output_names`.
>
> If `plugin` is a non-empty string, `sol_func` will be replaced with the wrapped version, `cse_6040_devkit.plugins.{plugin}(sol_func, **plugin_kwargs)`. If the wrapped version takes extra arguments, they must be provided in `extra_param_names`.
>
> If `include_hidden` is set, it will override the class-level setting. When `True`, hidden tests are included. When `False` they are not.
>
> The test cell for `ex_name` will appear in the startercode, populated with code to test student solutions.

#### `@register_helper(ex_name: str)`

> **Decorates** a function to register it as a _**helper**_ for `ex_name`.
>
> The function definition will be included in the starter code for the `ex_name` solution. This is above the solution stub so the helper function can be used by students in the solution.
>
> The function's _docstring_ will be included in the `ex_name` prompt.

#### `@register_util()`

> **Decorates** a function to register it as a _**util**_.
>
> The registered function will be serialized and callable as `cse_6040_devkit.utils.{name}` where `{name}` is the name of the function.
>
> > **Note**: proper usage is `@bp.register_util()` followed by the function definition. Using `@bp.register_util` (without the parenthesis) will raise an error.

#### `@register_plugin()`

> **Decorates** a function to register it as a _**plugin**_.
>
> The registered function will be serialized and callable as `cse_6040_devkit.plugins.{name}` where `{name}` is the name of the function.
>
> > **Note**: proper usage is `@bp.register_plugin()` followed by the function definition. Using `@bp.register_plugin` (without the parenthesis) will raise an error.

#### `register_preload_object(ex_name: str, obj: object, obj_name: str)`

> Registers `obj` as a _**preload object**_ for `ex_name`.
>
> The object, `obj`, will available in the student environment as `{obj_name}`.
>
> > **Note**: it is recommended to use the name of `obj` for `obj_name`. For example: `bp.register_preload_object('some_exercise', some_data_object, 'some_data_object')`



## AssignmentBuilder

### Constructor

#### `AssignmentBuilder(config_path='resource/asnlib/publicdata/assignment_config.yaml', notebook_path='main.ipynb',keys_path='keys.dill', header=True, include_hidden=True, data_path='data', publicdata_path='resource/asnlib/publicdata', kernelspec={'kernelspec': {"display_name": "Python 3.8", "language": "python", "name": "python38"}})`

> Uses these files and directories. They will be populated with usable defaults if they do not exist.
>
> - `config_path` (file): resource/asnlib/publicdata/assignment_config.yaml
> - `notebook_path` (file): main.ipynb
> - `keys_path` (file): keys.dill
> - `data_path` (directory): data
> - `publicdata_path` (directory): resource/asnlib/publicdata
>
> The `include_hidden` parameter toggles whether hidden tests are included by default. **This is only respected for samplers registered _directly_ to the `AssignmentBuilder`**.
>
> The `header` parameter toggles whether the exam header is included.
>
> The target notebook metadata attribute is set to `kernelspec` when it is written.

### Methods

#### `register_blueprint(other: AssignmentBlueprint)`

> Updates the AssignmentBuilder by registering all of `other`'s objects and functions. Collisions should be avoided by good practice:
>
> - For the same `ex_name`: *solution*, *demo*, *helper*, or *sampler* collisions raise an error.
> - For the same `ex_name`: *preload objects* with name collisions, `other`'s object is kept.
> - For `utils` and `plugins` with name collisions, `other`'s function is kept.

#### `register_blueprints(others: list[AssignmentBlueprint])`

> Registers all AssignmentBlueprints in `others` one-by-one in series.

#### `build()`

> Builds the assignment Jupyter notebook and data files.
>
> Updates the configuration file with defaults for any exercise, input, output which was not in the file pre-build.
> > **Note**: The updates to the configuration file are _additive_ only. Any changes which require removing or changing informaiton must be done manually.
>
> > **Note**: It is **not recommended** to hard-code configuration as part of the assignment definition code. 
>
> Copies files from `data_path` to `publicdata_path` if the filenames are not found in `publicdata_path`.

## Additional functions

#### `execute_tests(func: function, ex_name: str, key: bytes, n_iter: int, hidden=False, conf_path='resource/asnlib/publicdata/assignment_config.yaml', path='resource/asnlib/publicdata/')`

> Reads configuration for `ex_name` from `conf_path` and the test case from `{path}tc_{ex_name}` using decryption `key`. Tests `func` for `n_iter` iterations. It `hidden` is `True`, the hidden tests are executed.
>
> **This function is called in the assignment test cells with parameters filled in by a template. Developers will not have to use this manually.**
