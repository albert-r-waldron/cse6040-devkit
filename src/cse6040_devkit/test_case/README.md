# Test Case Generators

The provided implementation of the Tester framework operates on the assumption that test cases are available as files storing the inputs and expected output for a particular function to test. The Test Case Generator class exists to facilitate generating those files.

## Usage

The simplest way to use this framework is to instanciate a `SampleGenerator` object. The constructor takes 3 arguments.

- `test_func` - the function for which cases are being generated.
- `sampler_func` - a function to produce sample inputs for `test_func`. More details on the requirements for this function below.
- `output_names` (optional) - the names to key the outputs to. Defaults to `('output_0', ...)` for the number of outputs generated by `test_func`.

```
from test_case import SampleGenerator

# assumes `test_func`, `sampler_func` already defined
output_names = ['foo', 'bar']
tc_gen = SampleGenerator(test_func, sampler_func, output names)
```

Then, call the `write_cases` method, which takes 3 parameters:

- `path` - the path to write the file to.
- `n_cases` (optional) - the number of cases to be written. Defaults to `100`. Be mindful of file size when setting this parameter.
- `key` (optional) - binary Fernet encryption key. All files generated are encrypted. The key is necessary to decrypr the file. As a security measure you should rotate keys and store them securely. A default of `b'sIRWMgIhwENImJyOel3HWJDMr0VbXzfbq-uwgd09VFs='` is provided. If `None` is passed as the `key` parameter, a new key will be generated.

The key used for encryption is returned.
```
path = 'path/to/generated/file'
n_cases = 150


encryption_key = tc_gen.write_cases(path, n_cases, key)
```

### Requirements for `sampler_func`

- Takes no arguments
- Returns a `dict` mapping parameter names to a sample values.

```
def sampler_func():
    ### custom stuff to set `arg_0_val` and `arg_1_val`
    return {
        'arg_0': arg_0_val,
        'arg_1': arg_1_val
    }
```

**Database connection support**

Due to serialization requirements database connection parameters must be handled specially. If a database connection is required, return a `str` containing the name of the connection parameter in addition to the `dict`. The value associated with the `str` returned should be a `dict` mapping table names to Pandas DataFrames.

```
### `arg_2` will be handled as a database containing the three tables.
def sampler_func():
    ### custom stuff to set `arg_0_val` and `arg_1_val`
    ### custom stuff to set `df_2_0`, `df_2_1`, and `df_2_2`

    return {
        'arg_0': arg_0_val,
        'arg_1': arg_1_val,
        'arg_2': {
            'table_0': df_2_0,
            'table_1': df_2_1,
            'table_2': df_2_2
        }
    }, 'arg_2' 
```
**Support for functions as arguments**  
To allow for testing students' understanding of "higher-order functions" this framework uses the `dill` library for serialization. This allows the serialization of Python functions. Having the sampler function randomly generate functions or randomly choose from a collection is fully supported without any additional configuration.

## Additional functionality

Additional methods are provided for debugging and ensuring that the files being written contain the expected data.

- `make_case()` - returns a single test case. 
  - Returns `dict` mapping all input and output names to values for a single test case. Called by `write_cases` to prepare file content.
- `read_cases(path, key)` - reads test cases from a file specified by `path` and decrypts using the Frenet key, `key`. 
  - Returns `list` of `dict`s. Each dict is one test case mapping input/output variable names to values.

## Custom generators

The `TestCaseGenerator` can be extended to generate test cases in a different way. The `make_inputs` and `make_outputs` methods need to be defined per the directions in the `test_case_gen.py` comments.
